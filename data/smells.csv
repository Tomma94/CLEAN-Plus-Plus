Smell;Origin Tool;Type;Rule;Description
ImperativeAbstraction;DesigniteJava;Abstraction;NOPM != 1 or E[method].LOC(method)>LargeLOC;This smell arises when an operation is turned into a class.
MultifacetedAbstraction;DesigniteJava;Abstraction;LCOM > LargeLCOM and NOF > ManyFields and NOM > ManyMethods;This smell arises when an abstraction has more than one responsibility assigned to it.
UnnecessaryAbstraction;DesigniteJava;Abstraction;NOM = 0 and NOF <= FewFields;This smell occurs when an abstraction that is actually not needed (and thus could have been avoided) gets introduced in a software design.
UnutilizedAbstraction;DesigniteJava;Abstraction;(hasSuperTypes and not hasSuperTypesWithFanIn) or not hasFanIn;This smell arises when an abstraction is left unused (either not directly used or not reachable).
DeficientEncapsulation;DesigniteJava;Encapsulation;NOPF>0;This smell arises when the number of public fields is higher than 0
UnexploitedEncapsulation;DesigniteJava;Encapsulation;E(method1.instantiated(type1), method1.instantiated(type2)): type1 != type2 and sameHierarchy(class(type1),class(type2);This smell arises when there are two different classes that are instantiated in a method but they belong to the same hierarchy, i.e., one extends the other.
BrokenModularization;DesigniteJava;Modularization;NOM = 0 AND NOF > LargeNOF;This smell arises when data and/or methods that ideally should have been localized into a single abstraction are separated and spread across multiple abstractions.
InsufficientModularization;DesigniteJava;Modularization;NOPM >= LargeNOPM OR NOM >= LargeNOM OR WPC >= HighComplexity;This smell arises when an abstraction exists that has not been completely decomposed, and a further decomposition could reduce its size, implementation complexity, or both.
HubLikeModularization;DesigniteJava;Modularization;FANIN >= Large AND FANOUT >= Large;This smell arises when an abstraction has dependencies (both incoming and outgoing) with a large number of other abstractions.
Abstract Function Call From Constructor;DesigniteJava;Abstraction;M is constructor AND M calls at least one Abstract(method);This smell arises when the constructor of a class calls an abstract function
Complex Conditional;DesigniteJava;Abstraction;M has at least one if-else IE where: #(Expression(IE)) >= 3;This smell arises when a piece of code has a complex conditional statement, such as multiple nested if-else statements or large numbers of conditions that are hard to understand.
Complex Method;DesigniteJava;Abstraction;CC >= 8;This smell arises when a method contains too many lines of code or too many branches of logic, making it difficult to understand and maintain.
Empty catch clause;DesigniteJava;Abstraction;M has at least one catch block that is empty;This smell arises when a catch block is present but doesn't contain any code, this is also known as a catch-all.
Long Identifier;DesigniteJava;Abstraction;LengthName(Parameter(M)) >= 30 OR LengthName(LocalVariable(M)) >= 30 OR Length(AccessedField(M)) >= 30;This smell arises when identifiers such as variable, function, or class names are too long and make the code hard to read and understand.
Long Method;DesigniteJava;Abstraction;LOC(M) >= 100 OR MLOC > AVG(MLOC) AND MLOC > 30;This smell arises when a method becomes too long and complex, making it difficult to understand and maintain.
Long Parameter List;DesigniteJava;Abstraction;#Parameters >= 5 OR ParameterCount > AVG(ParameterCount) AND ParameterCount > 3;This smell arises when a method or function has a large number of parameters, making it hard to understand the purpose of the function and how the parameters are used.
Long Statement;DesigniteJava;Abstraction;Length(Statement) > 120;This smell arises when a statement or expression becomes too complex and difficult to understand, often due to the use of many nested conditions or a large number of operators.
Magic Number;DesigniteJava;Abstraction;For all the literals in the method, check if they are valid (check what is magic number below);This smell arises when a hard-coded number is used in the code without an explanation or clear meaning.
Missing default;DesigniteJava;Abstraction;In a switch-case structure in M, it doesn't include the default case;This smell arises when a class or function does not have a default case for a switch statement or a default branch for an if-else statement.
Lazy Class;Organic;Abstraction;CLOC < CLOCFirstQuartile;This smell arises when a class does not have a single, well-defined responsibility and often contains methods that should be in other classes.
Swiss Army Knife;Organic;Abstraction;InterfaceMethodDeclarationCount > VeryHighInterfaceMethodDeclarationCount;This smell arises when a class has many responsibilities and functionality, making it difficult to understand and maintain.
Data Class;Organic;Modularization;(((NOPA + NOAM) > Few AND WMC < HighWMC) OR (NOPA + NOAM) > Many AND WMC < VeryHighWMC)) AND WOC < OneThird;This smell arises when a class  primarily contains properties and does not have any significant behavior.
Complex Class;Organic;Abstraction;CC > 10;This smell arises when a class becomes overly complex, with many methods and properties that perform a variety of different tasks.
Refused Bequest;Organic;Hierarchy;OverrideRatio > 0.5 ;This smell arises when a subclass does not use or override methods or properties that are inherited from its superclass, effectively 'refusing' the inheritance.
Spaghetti Code;Organic;Abstraction;LongMethodsConnected > 2;This smell arises when the codebase is poorly structured and difficult to understand, often characterized by a lack of modularity and a high degree of interdependence between different parts of the code.
Large Class;Organic;Abstraction;CLOC > VeryHighCLOC;This smell arises when a class has grown too large and contains too many methods or properties, making it difficult to understand and maintain.
Class Data Should Be Private;Organic;Encapsulation;PublicFieldCount >= 1;This smell arises when class data is exposed publicly, rather than being kept private and only accessible through methods.
God Class;Organic;Modularization;CLOC > 500 AND TCC < AVG(TCC);This smell arises when a class has too many responsibilities, and becomes too large and complex to understand and maintain.
Speculative Generality;Organic;Hierarchy;IsAbstractChildrenCount < 3;This smell arises when code is implemented with the idea of possible future requirements that may or may not actually happen.
Brain Class;Organic;Modularization;((BrainMethodCount > 1 AND LOC >= VeryHighCLOC) OR (BrainMethodCount = 1 AND LOC >= TwiceVeryHighCLOC AND WMC >= TwiceVeryHighWMC)) AND (WMC >= VeryHighWMC AND TCC < Half);This smell arises when a class or module contains too much complex logic or calculations, and becomes difficult to understand and maintain.
Brain Method;Organic;Modularization;MLOC > high(CLOC)/2 AND CC > high(CC) AND MaxNesting > 5.0 AND NOAV > 6.0;This smell arises when a method has too much complex logic or calculations, and becomes difficult to understand and maintain.
Dispersed Coupling;Organic;Modularization;CINT > 8.0 AND CDISP > 0.5 AND MaxNesting > 1.0;This smell arises when classes or modules are tightly coupled, but the dependencies are spread out across multiple methods or properties, rather than being localized in a single place.
Intensive Coupling;Organic;Modularization;(CINT > 8.0 OR CDISP < 0.25) AND MaxNesting > 1.0;This smell arises when classes or modules are overly dependent on one another, making it difficult to understand and maintain.
Message Chain;Organic;Abstraction;MaxCallChain > 3;This smell arises when an object sends a message to another object and the second one sends another message to another object and so on, leading to a chain of message passing that can make the code hard to follow and understand.
Shotgun Surgery;Organic;Abstraction;CM > 8.0 AND CC > 6.0;This smell arises when a small change in the codebase requires a large number of classes or modules to be modified
