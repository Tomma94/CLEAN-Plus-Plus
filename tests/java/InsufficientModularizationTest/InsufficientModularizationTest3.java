// The class has cyclomatic complexity higher than 100.
// -> Has insufficient modularization smell.
public class InsufficientModularizationTest3 //Type originates from: InsufficientModularizationTest3.h
{
	public final void func1(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	public final void func2(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	public final void func3(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	public final void func4(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	public final void func5(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	public final void func6(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	private void func7(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	private void func8(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	private void func9(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	private void func10(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

	private void func11(int p1, int p2, int p3) //Method definition originates from: InsufficientModularizationTest3.cpp
	{
		for (int i = 0; i < 10; i++)
		{
			if (i == 0)
			{
				p1 = 0;
			}
			if (i < 5)
			{
				p1--;
			}
			p1++;
		}
		int v = 0;
		while (true)
		{
			v++;
			break;
		}
		switch (p3)
		{
			case 1:
				p3++;
			case 2:
				p3--;
			default:
				p3 = 0;
		}
		try
		{
			if (p1 < 0)
			{
				throw (0);
			}
			if (p1 > 0)
			{
				p1++;
			}
		}
		catch (int i)
		{
			p3 = i;
		}
	}

}
