// The class has not cyclomatic complexity higher than 100, and not more than 20 public methods, and not more than 30 methods.
// -> Has not insufficient modularization smell.
#include "NotInsufficientModularizationTest.h"

void NotInsufficientModularizationTest :: func1(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func2(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func3(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func4(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func5(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func6(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func7(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}
void NotInsufficientModularizationTest :: func8(int p1, int p2, int p3) {
    for (int i = 0; i < 10; i++) {
        if (i == 0) {
            p1 = 0;
        }
        if (i < 5) {
            p1--;
        }
        p1++;
    }
    int v = 0;
    while (true) {
        v++;
        break;
    }
    switch (p3) {
        case 1:
            p3++;
        case 2:
            p3--;
        default:
            p3 = 0;
    }
    try {
        if (p1 < 0) {
            throw (0);
        }
        if (p1 > 0) {
            p1++;
        }
    } catch (int i) {
        p3 = i;
    }
}